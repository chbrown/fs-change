#!/usr/bin/env node
'use strict'; /*jslint node: true, es5: true, indent: 2 */
var async = require('async');
var child_process = require('child_process');
var fs = require('fs');
var glob = require('glob');
var path = require('path');
var winston = require('winston');
var _ = require('underscore');

var argv = require('optimist').default({
  config: path.join(process.env.HOME, '.less-watch'),
  log: path.join(process.env.HOME, 'Library', 'Logs', 'less-watch.log'),
}).argv;

var logger = new (winston.Logger)({
  transports: [
    new (winston.transports.Console)(),
    new (winston.transports.File)({filename: argv.log})
  ]
});

function watch(filepath, command_template) {
  // for each file, interpolate its command
  var command_context = {
    file: filepath,
    extname: path.extname(filepath),
    basename: path.basename(filepath, path.extname(filepath)),
    dirname: path.dirname(filepath)
  };

  var command = command_template.replace(/\{(.+?)\}/g, function(full_match, group_1) {
    return command_context[group_1];
  });

  var changed = function(event) {
    // TODO: check last modified stats?
    logger.verbose('Saw ' + event + ' on ' + filepath);
    // if (curr.mtime.valueOf() != prev.mtime.valueOf() ||
    //   curr.ctime.valueOf() != prev.ctime.valueOf()) {
    logger.info('$ ' + command);
    child_process.exec(command, function (err, stdout, stderr) {
      if (err) logger.error(err);
      if (stdout) logger.info('stdout: ' + stdout);
      if (stderr) logger.info('stderr: ' + stdout);
    });
  };
  return fs.watch(filepath, _.debounce(changed, 2000, true));
}

var watchers = [];

function readConfig() {
  logger.info('Stopping ' + watchers.length + ' watchers');
  watchers.forEach(function(watcher) { watcher.close(); });

  logger.info('Reading config: ' + argv.config);
  // watched_filepaths.length ? "Reloading" : "Loading");

  // "restart" is a special action keyword
  // watch(config_path, 'restart');
  fs.readFile(argv.config, 'utf8', function (err, data) {
    if (err) logger.error(err);

    var lines = data.trim().split(/\n+/g);
    logger.info('Globbing ' + lines.length + ' patterns');

    // we have a bunch of globs, we want to flatmap them all to a list of filepaths
    async.map(lines, function(line, callback) {
      var parts = line.match(/^(.+?):(.+)$/);
      var pattern = parts[1].trim();
      var command = parts[2].trim();
      glob(pattern, function(err, filepaths) {
        if (err) logger.error(err);
        // for single files, filepaths will just be one file: the exact match
        var watchers = filepaths.map(function(filepath) {
          // zip up each filepath with the command that goes with its glob
          return watch(filepath, command);
        });
        callback(null, watchers);
      });
    }, function(err, watcherss) {
      if (err) logger.error(err);
      watchers = [].concat.apply([], watcherss);
      logger.info('Created ' + watchers.length + ' watchers');
    });
  });
}

var configChanged = function(event) {
  logger.info('Config changed: ' + argv.config);
  readConfig();
};
fs.watch(argv.config, _.debounce(configChanged, 2000, true));

readConfig();
